
``1-my_list`` module Defines How to Utilize 1-my_list.py
=========================================================

A module that defines a class ``MyList`` which inherit from ``list``
--------------------------------------------------------------------

Instanstations
--------------

Instantiating ``MyList`` with no argument must return an empty list
Import function from the module:
	>>> MyList = __import__('1-my_list').MyList
        >>> my_list = MyList()
        >>> type(my_list)
        <class '1-my_list.MyList'>

         print(my_list)
         []

Testing for Module docstring:
	>>> mod = __import__('1-my_list').__doc__
	>>> len(mod) > 1
	True

Testing for class docstring:
	>>> cls = __import__('1-my_list').MyList.__doc__
	>>> len(cls) > 1
	True

Testing for method docstring:
	>>> mtd = __import__('1-my_list').MyList.print_sorted.__doc__
	>>> len(mtd) > 1
	True

Testing that MyList inherit from list:
	>>> issubclass(MyList, list)
	True

Instantiating ``MyList`` with a single argument which must be an iteratable object
	>>> my_list = MyList([1, 2, 3])
	print(my_list)
	[1, 2, 3]

'None' TypeError for none iteratable object
	>>> my_list = MyList(None)
	Traceback (most recent call last):
	TypeError: 'NoneType' object is not iterable

TypeError for more than one instantiation argument
	>>> my_list = MyList([1, 2], [3, 4])
	Traceback (most recent call last):
	TypeError: list expected at most 1 argument, got 2

Usage
=====

``MyList`` is a child class to the parent class ``list``, it thus inherited all the 
methods and attributes of the parent class. One of the attributes inherited is ``append()``
which allows for adding element to ``MyList``.
	
	>>> my_list = MyList()
	>>> my_list.append(1)
	>>> my_list.append(2)
	>>> my_list.append(3)
	>>> my_list.append(4)
	>>> print(my_list) 
	[1, 2, 3, 4]

Implementing a public instance method.
``print_sorted(self)``

	>>> my_list = MyList()
	>>> print(my_list.print_sorted)
	<bound method MyList.print_sorted of []>

Implementing a method that takes no argument - a TypeError will be returned
if an argument is provided.

	>>> my_list.sorted(1)
	Traceback (most recent call last):
	TypeError: print_sorted() takes 1 positional arguement but 2 were given

Testing for list sorted in ascending order

	>>> my_list = MyList()
	>>> my_list.append(4)
	>>> my_list.append(-2)
	>>> my_list.append(-4)
	>>> my_list.append(0)
	>>> my_list.append(3)
	>>> my_list.append(1)
	>>> print(my_list)
	[4, -2, -4, 0, 3, 1)

	>>> my_list.print_sorted()
	[-4, -2, 0, 1, 3, 4]


Testing for list already sorted in ascending order

	>>> my_list = MyList()
	>>> my_list.append(-2)
	>>> my_list.append(-1)
	>>> my_list.append(0)
	>>> my_list.append(1)
	>>> my_list.append(2)
	>>> my_list.append(3)
	>>> print(my_list)
	[-2, -1, 0, 1, 2, 3]

	>>> my_list.print_sorted()
	[-2, -1, 0, 1, 2, 3]

Testing for reversed order list
	
	>>> my_list = MyList()
	>>> my_list.append(3)
	>>> my_list.append(2)
	>>> my_list.append(1)
	>>> my_list.append(0)
	>>> my_list.append(-1)
	>>> my_list.append(-2)
	print(my_list)
	[3, 2, 1, 0, -1, -2]

	>>> my_list.print_sorted()
	[-2, -1, 0, 1, 2, 3]

Testing for an empty list

	>>> my_list = MyList()
	>>> my_list.print_sorted()
	[]
